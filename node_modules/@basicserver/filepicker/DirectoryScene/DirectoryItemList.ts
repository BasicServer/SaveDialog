import { DirectorySceneCfg } from './DirectoryScene';
import { GenericScene } from '@frugal-ui/base';
import { IdentifiableObjectMap } from '@frugal-ui/base';
import { IdentifiableDirectoryItem } from '../Data/IdentifiableDirectoryItem';
import { State } from '@frugal-ui/base';
import { UUID } from '@frugal-ui/base';
import { getDirectoryListing } from '../helpers';
import { ScrollArea } from '@frugal-ui/base';
import { VisualGroup } from '@frugal-ui/base';
import { HStack } from '@frugal-ui/base';
import { Icon } from '@frugal-ui/base';
import { Input } from '@frugal-ui/base';
import { TextInputCfg } from '@frugal-ui/base';
import { List } from '@frugal-ui/base';
import { ListStyles } from '@frugal-ui/base';
import { DirectoryItemView } from './DirectoryItemView';
import { listUpdater } from '..';

export interface DirectoryItemListCfg extends DirectorySceneCfg {
	parentScene: GenericScene<any>;
}

export function DirectoryItemList(configuration: DirectoryItemListCfg) {
	const { path } = configuration;

	const itemMap = new IdentifiableObjectMap<IdentifiableDirectoryItem>();
	const visibleItems = new State(
		new IdentifiableObjectMap<IdentifiableDirectoryItem>(),
	);
	const searchString = new State('');

	const updateBinding = {
		uuid: new UUID(),
		action: refresh,
	};
	listUpdater.addBinding(updateBinding);

	searchString.addBinding({
		uuid: new UUID(),
		action: update,
	});

	async function refresh() {
		try {
			const listing = await getDirectoryListing(path);

			//add new items
			for (let i = 0; i < listing.length; i++) {
				const item = listing[i];
				const matchInItemMap = itemMap
					.values()
					.find((mapItem) => mapItem.name == item.name);

				if (matchInItemMap == undefined) {
					const identifiableItem = new IdentifiableDirectoryItem(
						item,
						i,
					);
					itemMap.set(identifiableItem);
				} else {
					matchInItemMap.index.value = i;
				}
			}

			//remove items
			itemMap.forEach((item) => {
				const matchInListing = listing.find(
					(listingItem) => listingItem.name == item.name,
				);
				if (matchInListing != undefined) return;

				itemMap.remove(item);
			});

			update();
		} catch {
			listUpdater.removeBinding(updateBinding);
			configuration.parentScene.close();
		}
	}

	function update() {
		//remove deleted items
		visibleItems.value.forEach((item) => {
			const matchInItemMap = itemMap.get(item.uuid);
			if (matchInItemMap == undefined)
				return visibleItems.value.remove(item);
		});

		//add new & apply search
		itemMap.forEach((item) => {
			const shouldBeVisible =
				item.name
					.toLowerCase()
					.indexOf(searchString.value.toLowerCase()) != -1;

			if (shouldBeVisible) {
				visibleItems.value.set(item);
			} else {
				visibleItems.value.remove(item);
			}
		});

		visibleItems.triggerAll();
	}

	refresh();

	return ScrollArea(
		VisualGroup(
			HStack(
				Icon('search')
					.cssPadding('var(--padding-md)')
					.cssPaddingRight('0rem'),
				Input(new TextInputCfg(searchString, 'Search items...')),
			),

			List(
				{
					style: ListStyles.Normal,
					listData: visibleItems,
				},
				(item) =>
					DirectoryItemView({
						...configuration,
						parent: path,
						item,
					}),
			),
		),
	).useDefaultPadding();
}
