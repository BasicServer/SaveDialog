import {
	BindableObject,
	Button,
	ButtonStyles,
	Component,
	ComputedState,
	GenericScene,
	Header,
	HStack,
	Icon,
	Identifiable,
	IdentifiableObjectMap,
	Input,
	Label,
	List,
	ListStyles,
	NavigationLink,
	Popover,
	SceneTypes,
	ScrollArea,
	SelectingListItem,
	Separator,
	Sortable,
	Spacer,
	Stage,
	State,
	Text,
	TextInputCfg,
	UUID,
	VisualGroup,
	VStack,
} from '@frugal-ui/base';
import {
	cp,
	mkdir,
	readdir,
	rename,
	rm,
	writeFile,
} from '@basicserver/fs-frontend';

// Types
export enum Types {
	File,
	Directory,
}

interface Clipboard {
	name: BindableObject<string>;
	path: BindableObject<string>;
}

interface DirectoryItem {
	name: string;
	isDirectory: boolean;
}

export class SelectedItem {
	name? = '';
	path? = '';
	isDirectory? = false;

	listener: (item: SelectedItem) => void;

	constructor(listener: SelectedItem['listener']) {
		this.listener = listener;
	}

	set(name: SelectedItem['name'], path: SelectedItem['path'], isDirectory: SelectedItem['isDirectory']) {
		this.name = name;
		this.path = path;
		this.isDirectory = isDirectory;

		this.listener(this);
	}

	clear() {
		this.name = undefined;	
		this.path = undefined;	
		this.isDirectory = undefined;	

		this.listener(this);
	}
}

class IdentifiableDirectoryItem implements Identifiable, Sortable {
	uuid = new UUID();
	index = new State(0);

	name: string;
	isDirectory: boolean;

	constructor(item: DirectoryItem, index: number) {
		this.name = item.name;
		this.isDirectory = item.isDirectory;
		this.index.value = index;
	}
}

type DirectoryListing = DirectoryItem[];

// Main
const listUpdater = new State(null);
function updateLists() {
	listUpdater.triggerAll();
}

export default function FilePicker(
	rootName: string,
	initialPath: string,
	selectedItem: SelectedItem,
	allowedTypes: Types[],
) {
	const clipboard: Clipboard = { name: new State(''), path: new State('') };

	return Stage(DirectoryScene, {
		rootName,
		isFirst: true,
		path: initialPath,
		selectedItem,
		allowedTypes,
		clipboard,
	});
}

// Directory
interface DirectorySceneCfg {
	rootName: string;
	isFirst: boolean;
	path: string;
	selectedItem: SelectedItem;
	allowedTypes: Types[];
	clipboard: Clipboard;
}

class DirectoryScene extends GenericScene<DirectorySceneCfg> {
	draw(data: DirectorySceneCfg) {
		const { rootName, path } = data;

		this.type = SceneTypes.Column;
		this.accessibilityLabel = `directory ${rootName}`;

		return VStack(
			Header(
				{
					text: rootName.substring(0, 9),
				},
				PastePopover(data),
				Button({
					accessibilityLabel: 'refresh directory list',
					iconName: 'refresh',
					action: updateLists,
				}),
				CreationPopover({
					typeName: 'File',
					iconName: 'note_add',
					creationFn: async (newName) =>
						await writeFile(`${path}/${newName}`, ''),
				}),
				CreationPopover({
					typeName: 'Directory',
					iconName: 'create_new_folder',
					creationFn: async (newName) =>
						await mkdir(`${path}/${newName}`),
				}),
			),

			DirectoryItemList({
				...data,
				parentScene: this,
			}),

			Spacer(),
		);
	}

	setup() {
		this.view.cssWidth('24rem');
	}
}

function PastePopover(configuration: DirectorySceneCfg) {
	const { clipboard, path } = configuration;

	const isClipboardEmpty = new ComputedState({
		statesToBind: [clipboard.name, clipboard.path],
		initialValue: true,
		compute(self) {
			self.value = clipboard.path.value == '';
		},
	});

	async function paste(action: 'copy' | 'move') {
		try {
			const src = clipboard.path.value;
			const dest = `${path}/${clipboard.name.value}`;
			console.log(src, dest);

			switch (action) {
				case 'copy':
					await cp(src, dest);
					break;
				case 'move':
					await rename(src, dest);
					clipboard.path.value = dest;
					break;
			}

			updateLists();
		} catch (error) {
			alert(`Failed to ${action} to ${path}: ${error}`);
		}
	}

	const isOpen = new State(false);
	return Popover({
		accessibilityLabel: 'copy or move here',
		isOpen,
		toggle: Button({
			accessibilityLabel: 'copy or move here',
			iconName: 'paste',
			action: () => (isOpen.value = !isOpen.value),
		}).toggleAttr('disabled', isClipboardEmpty),
		content: VStack(
			Text(clipboard.name)
				.cssMaxWidth('100%')
				.cssOverflow('hidden')
				.cssTextOverflow('ellipsis')
				.cssWhiteSpace('nowrap')
				.cssTextAlign('left'),
			Separator(),
			Button({
				accessibilityLabel: 'copy here',
				text: 'Copy here',
				action: () => paste('copy'),
			}),
			Button({
				accessibilityLabel: 'move here',
				text: 'Move here',
				action: () => paste('move'),
			}),
		)
			.cssWidth('14rem')
			.cssHeight('auto')

			.useDefaultSpacing()
			.useDefaultPadding(),
	});
}

interface CreationPopoverCfg {
	typeName: string;
	iconName: string;
	creationFn: (newName: string) => Promise<any>;
}

function CreationPopover(configuration: CreationPopoverCfg) {
	const { typeName, iconName, creationFn: createFn } = configuration;

	const isOpen = new State(false);
	const newName = new State('');

	async function create() {
		try {
			await createFn(newName.value);
			newName.value = '';
		} catch {
			alert(`Failed to create ${typeName} "${name}"`);
		}

		isOpen.value = false;
		updateLists();
	}

	return Popover({
		isOpen: isOpen,
		accessibilityLabel: `create ${typeName}`,
		toggle: Button({
			iconName: iconName,
			accessibilityLabel: `create ${typeName}`,
			action: () => (isOpen.value = !isOpen.value),
		}),
		content: VStack(
			Label(
				'Name',
				Input(
					new TextInputCfg(newName, 'Untitled'),
				).registerKeyboardShortcuts({ key: 'Enter', action: create }),
			),
			Button({
				style: ButtonStyles.Primary,
				accessibilityLabel: `create ${typeName}`,
				text: `Create ${typeName}`,
				action: create,
			}),
		)
			.cssHeight('auto')
			.cssWidth('18rem')
			.useDefaultPadding()
			.useDefaultSpacing(),
	});
}

interface DirectoryItemListCfg extends DirectorySceneCfg {
	parentScene: GenericScene<any>;
}

function DirectoryItemList(configuration: DirectoryItemListCfg) {
	const { path } = configuration;

	const itemMap = new IdentifiableObjectMap<IdentifiableDirectoryItem>();
	const visibleItems = new State(
		new IdentifiableObjectMap<IdentifiableDirectoryItem>(),
	);
	const searchString = new State('');

	function update() {
		//remove deleted items
		visibleItems.value.forEach((item) => {
			const matchInItemMap = itemMap.get(item.uuid);
			if (matchInItemMap == undefined)
				return visibleItems.value.remove(item);
		});

		//add new & apply search
		itemMap.forEach((item) => {
			const shouldBeVisible =
				item.name
					.toLowerCase()
					.indexOf(searchString.value.toLowerCase()) != -1;

			if (shouldBeVisible) {
				visibleItems.value.set(item);
			} else {
				visibleItems.value.remove(item);
			}
		});

		visibleItems.triggerAll();
	}

	async function refresh() {
		try {
			const listing = await getDirectoryListing(path);

			//add new items
			for (let i = 0; i < listing.length; i++) {
				const item = listing[i];
				const matchInItemMap = itemMap
					.values()
					.find((mapItem) => mapItem.name == item.name);

				if (matchInItemMap == undefined) {
					const identifiableItem = new IdentifiableDirectoryItem(
						item,
						i,
					);
					itemMap.set(identifiableItem);
				} else {
					matchInItemMap.index.value = i;
				}
			}

			//remove items
			itemMap.forEach((item) => {
				const matchInListing = listing.find(
					(listingItem) => listingItem.name == item.name,
				);
				if (matchInListing != undefined) return;

				itemMap.remove(item);
			});

			update();
		} catch {
			configuration.parentScene.close();
		}
	}

	listUpdater.addBinding({
		uuid: new UUID(),
		action: refresh,
	});
	refresh();

	searchString.addBinding({
		uuid: new UUID(),
		action: update,
	});

	return ScrollArea(
		VisualGroup(
			HStack(
				Icon('search')
					.cssPadding('var(--padding-md)')
					.cssPaddingRight('0rem'),
				Input(new TextInputCfg(searchString, 'Search items...')),
			),

			List(
				{
					style: ListStyles.Normal,
					listData: visibleItems,
				},
				(item) =>
					DirectoryItemView({
						...configuration,
						parent: path,
						item,
					}),
			),
		),
	).useDefaultPadding();
}

interface DirectoryItemViewCfg extends DirectoryItemListCfg {
	item: IdentifiableDirectoryItem;
	parent: string;
}

function DirectoryItemView(configuration: DirectoryItemViewCfg) {
	const { clipboard, item, selectedItem, parentScene, parent } = configuration;
	const path = `${parent}/${item.name}`;

	let component: Component<any>;

	if (item.isDirectory == true) {
		component = NavigationLink<DirectorySceneCfg>(
			{
				accessibilityLabel: item.name,
				parentScene,
				destination: DirectoryScene,
				data: {
					isFirst: false,
					path,
					rootName: item.name,
					selectedItem,
					allowedTypes: configuration.allowedTypes,
					clipboard,
				},
			},
			...ItemText({
				...configuration,
				path,
				itemName: item.name,
				isDirectory: item.isDirectory,
			}),
		)
			.cssPaddingLeft('0rem')
			.cssPaddingTop('0rem')
			.cssPaddingBottom('0rem');
	} else {
		const uuid = new UUID();
		component = SelectingListItem(
			{
				ownValue: uuid,
				selection: configuration.parentScene.linkSelection,
				isExclusive: true,
			},
			...ItemText({
				...configuration,
				path,
				itemName: item.name,
				isDirectory: item.isDirectory,
			}),
		)
			.useDefaultSpacing()
			.cssPaddingLeft('0rem')
			.cssPaddingTop('0rem')
			.cssPaddingBottom('0rem')

			.listen('click', () => {
				parentScene.stage.goBackTo(parentScene.depth);
				parentScene.linkSelection.selectedItems.value = [uuid];
			});
	}

	return component.listen('click', () => {
		if (
			(item.isDirectory == true &&
				configuration.allowedTypes.indexOf(Types.Directory) == -1) ||
			(item.isDirectory == false &&
				configuration.allowedTypes.indexOf(Types.File) == -1)
		) {
			selectedItem.clear();
			return;
		}

		selectedItem.set(item.name, path, item.isDirectory);
	});
}

interface ItemTextCfg extends DirectoryItemViewCfg {
	itemName: string;
	isDirectory: boolean;
}

function ItemText(configuration: ItemTextCfg) {
	return [
		ItemOptionsMenu(configuration),
		Icon(configuration.isDirectory ? 'folder' : 'note'),
		Text(configuration.itemName)
			.cssFontFamily('mono-rg')
			.useDefaultPadding()
			.cssWidth('100%')
			.cssFlex(1)
			.cssTextAlign('left'),
	];
}

function ItemOptionsMenu(configuration: ItemTextCfg) {
	const { clipboard, parent, isDirectory, selectedItem } = configuration;
	let { itemName, path } = configuration;

	const isOpen = new State(false);
	const newItemName = new State(itemName);

	async function deleteItem() {
		try {
			await rm(path);
			if (clipboard.path.value == path) {
				clipboard.name.value = '';
				clipboard.path.value = '';
			}
			selectedItem.clear();	
		} catch {
			alert(`Failed to delete "${name}"`);
		}

		updateLists();
	}
	async function renameItem() {
		try {
			const newName = newItemName.value;
			const newPath = `${parent}/${newName}`;
			await rename(path, newPath);

			if (clipboard.path.value == path) {
				clipboard.path.value = newPath;
				clipboard.name.value = newName;
			}

			itemName = newName;
			path = newPath;
		} catch {
			alert(`Failed to rename "${name}"`);
		}

		listUpdater.triggerAll();
	}
	function copy() {
		clipboard.name.value = itemName;
		clipboard.path.value = path;
		isOpen.value = false;
	}

	return Popover({
		isOpen,
		accessibilityLabel: 'options',
		toggle: Button({
			style: ButtonStyles.Transparent,
			accessibilityLabel: 'show options',
			iconName: 'more_vert',
			action: () => (isOpen.value = !isOpen.value),
		}).cssColor('inherit'),
		content: VStack(
			// name
			Label(
				'Name',
				Input(new TextInputCfg(newItemName, 'Untitled'))
					.addToClass('forcing-default-styles')
					.registerKeyboardShortcuts({
						key: 'Enter',
						action: renameItem,
					}),
			),
			Button({
				accessibilityLabel: 'rename item',
				iconName: 'edit',
				text: 'Rename',
				action: renameItem,
			}).addToClass('forcing-default-styles'),
			Separator(),

			// actions
			//open
			Button({
				accessibilityLabel: 'open file',
				iconName: 'open_in_new',
				text: 'Open',
				action: () =>
					window.open(`${window.location.origin}/file/${path}`),
			})
				.hideConditionally(isDirectory)
				.addToClass('forcing-default-styles'),

			//copy
			Button({
				accessibilityLabel: 'copy file',
				iconName: `${isDirectory ? 'folder' : 'file'}_copy`,
				text: 'Copy',
				action: copy,
			}).addToClass('forcing-default-styles'),

			//delete
			Button({
				style: ButtonStyles.Destructive,
				accessibilityLabel: 'delete item',
				iconName: 'delete',
				text: 'Delete',
				action: deleteItem,
			}).addToClass('forcing-default-styles'),
		)
			.cssHeight('auto')
			.cssWidth('18rem')
			.useDefaultPadding()
			.useDefaultSpacing(),
	}).listen('keydown', (event) => event.stopPropagation());
}

// Utility
async function getDirectoryListing(path: string) {
	const listingText = await readdir(path);
	const listing: DirectoryListing = JSON.parse(listingText);
	const cleaned = listing.filter((item) => item.name[0] != '.');
	return cleaned;
}
